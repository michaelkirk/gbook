<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Feature Creek - Geospatial Rust</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/css/style.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded affix "><li class="part-title">Lessons</li><li class="chapter-item expanded "><a href="youre-projecting.html"><strong aria-hidden="true">2.</strong> You're Projecting</a></li><li class="chapter-item expanded "><a href="feature-creek.html" class="active"><strong aria-hidden="true">3.</strong> Feature Creek</a></li><li class="chapter-item expanded "><a href="join-the-party.html"><strong aria-hidden="true">4.</strong> Join the Party</a></li><li class="chapter-item expanded affix "><li class="part-title">About This Book</li><li class="chapter-item expanded "><a href="contact.html"><strong aria-hidden="true">5.</strong> Contact the Authors</a></li><li class="chapter-item expanded "><a href="license.html"><strong aria-hidden="true">6.</strong> License</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Geospatial Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="feature-creek"><a class="header" href="#feature-creek">Feature Creek</a></h1>
<p>In the <a href="./youre-projecting.html">previous chapter</a> we worked with geometry stored in Well Known Text (WKT) format. It should come as no surprise that solving geospatial problems fundamentally involves geometry, but it’s rarely <em>exclusively</em> about geometry. Usually there are other attributes associated with that geometry that we also want to explore. This combination of a geometry with its associated attribute data is often referred to as a <em>feature</em>, and a group of features can be called a <em>feature collection</em>.</p>
<p><img src="images/philly-waterways.png" alt="Many spidering waterways consolidating into a major river" /></p>
<p>In addition to being the “City of Brotherly Love,” Philadelphia is also a city of water. We can describe shapes using Well Known Text, and all these waterways can be represented as a long list of WKT declarations:</p>
<ul>
<li><code>MULTIPOLYGON(....)</code></li>
<li><code>MULTIPOLYGON(....)</code></li>
<li><code>MULTIPOLYGON(....)</code></li>
<li>…</li>
</ul>
<h2 id="cry-me-a-rivers"><a class="header" href="#cry-me-a-rivers">Cry Me a River(s)</a></h2>
<p>You can say “I’m going for a walk down by <em>the</em> river” if you live in a one-river town, but in Philadelphia you need to be a little more specific. Let’s associate a name with each of these shapes to clarify which river we’re talking about.</p>
<div class="table-wrapper"><table><thead><tr><th>creek_name</th><th>geometry</th></tr></thead><tbody>
<tr><td>Wissahickon Creek</td><td>MULTIPOLYGON(….)</td></tr>
<tr><td>Schuylkill River</td><td>MULTIPOLYGON(….)</td></tr>
<tr><td>Delaware River</td><td>MULTIPOLYGON(….)</td></tr>
</tbody></table>
</div>
<p><img src="images/philly-waterways-labeled.png" alt="The many rivers of Philadelphia again, but with labels this time; the Delaware on the east, and the Schuylkill from the northwest" /></p>
<p>Now we’re talking specifics! The Delaware River defines Philadelphia’s eastern boundary, and the Schuylkill River runs through the city from the North West. Even though it’s not in very many spellcheck dictionaries, the Wissahickon is still a local favorite for urban walkers, so let’s amble over to the Wissahickon Valley Park.</p>
<h2 id="bridging-the-gap"><a class="header" href="#bridging-the-gap">Bridging the Gap</a></h2>
<p><img src="images/philly-wissahickon-valley-park.png" alt="Detail of the Wissahickon Creek" /></p>
<p>Walking <em>near</em> water is neat, and walking <strong>on</strong> water is an advanced topic for <a href="https://en.wikipedia.org/wiki/Bible">another book</a>, but walking <em>over</em> water? Now that’s an infrastructural thrill within reach! So how do we find which segments of the Wissahickon have a bridge? Combining a geometry with other associated data into a <em>feature</em> allows us to solve these kinds of problems.</p>
<p>There are a lot of ways we can represent geospatial information. Recall that well-known text (WKT) is only concerned with representing a shape — it can’t store whether that shape represents a bridge or has a name. One approach is to embed WKT into <em>another</em> more flexible format such as a CSV file, with one column containing WKT to describe the shape of the feature, and each additional column including another attribute, such as the name of the waterway or whether the segment has a bridge.</p>
<p><img src="images/philly-bridge-selected.png" alt="Zoomed in segment of a winding waterway, with one narrow segment highlighted" /></p>
<p>This <a href="data/philly_waterways/philly_waterways.csv">CSV of Philadelphia waterway segments</a> does just that. Here’s an excerpt:</p>
<div class="table-wrapper"><table><thead><tr><th>creek_name</th><th>inf1</th><th>geometry</th></tr></thead><tbody>
<tr><td>Cobbs Creek</td><td></td><td>MULTIPOLYGON(….)</td></tr>
<tr><td>Cobbs Creek</td><td>Bridged</td><td>MULTIPOLYGON(….)</td></tr>
<tr><td>Wise’s Mill</td><td></td><td>MULTIPOLYGON(….)</td></tr>
<tr><td>Wissahickon Creek</td><td>Bridged</td><td>MULTIPOLYGON(….)</td></tr>
<tr><td>Wissahickon Creek</td><td></td><td>MULTIPOLYGON(….)</td></tr>
<tr><td>Wissahickon Creek</td><td>Bridged</td><td>MULTIPOLYGON(….)</td></tr>
</tbody></table>
</div>
<p>You’ll notice that a single creek is broken into many small segments in this data set. A “Bridged” segment indicates precisely where that bridge exists on the waterway (highlighted yellow in the image above).</p>
<h2 id="the-short-list-a-bridged"><a class="header" href="#the-short-list-a-bridged">The Short List (A-bridged)</a></h2>
<p>To make a handout for our “First Annual Wissahickon Walkabout,” we want to include a list of bridges where participants can cross the Wissahickon. Some of these bridges are quite lovely, providing tourists an ideal location for selfies, while fly fishers cast shade while casting in the shade below.</p>
<p>Let’s combine a little attribute inspection with a little geometric processing to find the best bridges for our walk:</p>
<header class="codeblock-header">Process a CSV</header>
<pre><code class="language-rust">use csv;
use geo::algorithm::{Centroid, Area};
use geo::geometry::{Point, Geometry};
use proj::Transform;
use wkt;

let mut feature_reader = {
  use std::fs::File;
  let file = File::open(&quot;src/data/philly_waterways/philly_waterways.csv&quot;).expect(&quot;file path must be valid&quot;);
  csv::Reader::from_reader(file)
};

let mut acceptable_walkabout_bridges: Vec&lt;Point&gt; = vec![];

for row in feature_reader.records() {
  let creek_segment = row.expect(&quot;must be able to read row from CSV&quot;);

  let creek_name = creek_segment.get(0).expect(&quot;'creek_name' field must be present&quot;);
  let infrastructure_label = creek_segment.get(1).expect(&quot;'inf1' field must be present&quot;);
  let geometry_str = creek_segment.get(2).expect(&quot;`geometry` field must be present&quot;);

  // We're only interested in Bridged segments.
  if infrastructure_label != &quot;Bridged&quot; {
    continue;
  }

  // We're only interested in bridges that cross Wissahickon Creek.
  if creek_name != &quot;Wissahickon Creek&quot; {
    continue;
  }

  // Ok, we've utilized some attributes to narrow our search,
  // now let's dig deeper with some geometric analysis.

  use wkt::TryFromWkt;
  let geometry = Geometry::try_from_wkt_str(geometry_str).expect(&quot;wkt must be valid&quot;);

  let bridge_centroid = geometry.centroid().expect(&quot;a centroid should exist for any non-empty geometry&quot;);

  // We're only interested in the part of the Wissahickon Creek that's within
  // the Wissahickon Valley Park.
  let SOUTHERN_PARK_BORDER = 40.013214;
  let NORTHERN_PARK_BORDER = 40.084306;
  if bridge_centroid.y() &lt; SOUTHERN_PARK_BORDER || bridge_centroid.y() &gt; NORTHERN_PARK_BORDER {
    continue;
  }

  // Compute the size of the bridge
  let bridge_area = {
    // In the previous article about projections, we learned how to transform lat/lon to a local
    // projection to get useful area calculations.
    //
    // WGS84 - World Geodetic System, aka lat/lon
    // EPSG:3364 - NAD83(HARN) / Pennsylvania South (meters)
    let geometry_in_meters = geometry.transformed_crs_to_crs(&quot;WGS84&quot;, &quot;EPSG:3364&quot;).expect(&quot;valid transformation&quot;);
    geometry_in_meters.unsigned_area()
  };

  // We're not intested in walking across large automobile bridges.
  if bridge_area &gt; 250.0 {
    continue;
  }

  // Using attribute data and geometric processing, we've identified a good walking bridge!
  acceptable_walkabout_bridges.push(bridge_centroid);
}

assert_eq!(acceptable_walkabout_bridges.len(), 8);
approx::assert_relative_eq!(acceptable_walkabout_bridges[3], Point::new(-75.22563703858332, 40.071892693259315));
</code></pre>
<p>Eight bridges seems like the perfect number of crossings for an enthusiastic walk about the Wissahickon. These bridges run the gamut, including wee pedestrian crossings, quick bicycle connectors, and a couple not-too-huge bridges shared with cars. One of the most interesting bridges we’ll encounter (near <a href="https://www.openstreetmap.org/#map=19/40.07189/-75.22563">40.07189°N, 75.22563°W</a>) is the historic <a href="https://en.wikipedia.org/wiki/Thomas_Mill_Covered_Bridge">Thomas Mill Covered Bridge</a>. Built in 1855 and fixed up by the <a href="https://en.wikipedia.org/wiki/Works_Progress_Administration">Works Progress Administration</a> in 1939, it’s the oldest covered bridge in any major US City.</p>
<p><img src="images/philly-thomas-mill-bridge.jpg" alt="historic black and white photograph of a covered bridge" /></p>
<p>Just like the Thomas Mill bridge probably felt in 1938, our code could benefit from a good <a href="https://en.wikipedia.org/wiki/New_Deal">deal</a> of tender loving care. One thing you may have noticed is the repetitive nature of <code>get</code>ting numbered fields from the CSV and then <code>expect</code>ing no errors:</p>
<header class="codeblock-header">Unfortunate Boilerplate</header>
<pre><code class="language-rust ignore">let creek_name = creek_segment.get(0).expect(&quot;'creek_name' field must be present&quot;);
let infrastructure_label = creek_segment.get(1).expect(&quot;'inf1' field must be present&quot;);
let geometry_str = creek_segment.get(2).expect(&quot;`geometry` field must be present&quot;);
</code></pre>
<p>For each row in the CSV, getting fields by number in an ad-hoc fashion like this is simple, but it’s a little loosey-goosey: We have to remember what order the fields are in and also write some boring error-checking boilerplate.</p>
<h2 id="a-structured-alternative"><a class="header" href="#a-structured-alternative">A <em>Struct</em>ured Alternative</a></h2>
<p>Instead, we can parse each row into a rigidly defined <code>struct</code>. Let’s take another look at our data:</p>
<div class="table-wrapper"><table><thead><tr><th>creek_name</th><th>inf1</th><th>geometry</th></tr></thead><tbody>
<tr><td>Wissahickon Creek</td><td>Bridged</td><td>MULTIPOLYGON(….)</td></tr>
</tbody></table>
</div>
<p>This schema can be converted into a Rust struct like this:</p>
<header class="codeblock-header">A Row in the CSV as a Rust Struct</header>
<pre><code class="language-rust">struct CreekSegment {
  creek_name: String,
  inf1: String,
  geometry: geo::geometry::Geometry
}
</code></pre>
<div class="callout rust-callout">
<h3 id="structs-in-rust"><a class="header" href="#structs-in-rust">Structs in rust</a></h3>
<p>A struct is a type that holds multiple related values. You can read more in <a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html">The Rust Book</a>.</p>
</div>
<p>Notice how each field of the <code>CreekSegment</code> struct corresponds to a column in our CSV input. From here, we could write boilerplate code to populate each of these fields:</p>
<header class="codeblock-header">Revised, but Still Unfortunate, Boilerplate</header>
<pre><code class="language-rust ignore">let creek_name = creek_segment.get(0).expect(&quot;'creek_name' field must be present&quot;);
let infrastructure_label = creek_segment.get(1).expect(&quot;'inf1' field must be present&quot;);
let geometry_str = creek_segment.get(2).expect(&quot;`geometry` field must be present&quot;);

let geometry = Geometry::try_from_wkt_str(geometry_str).expect(&quot;wkt must be valid&quot;);

let creek_segment = CreekSegment {
  creek_name,
  inf1: infrastructure_label,
  geometry
};
</code></pre>
<p>Deserializing information from a CSV file into a more ergonomic form like this isn’t exactly cutting-edge stuff in the world of Computer Science — actually it’s kind of tedious and error prone. Fortunately for us, we can stand on the shoulders of giants and turn to the wisdom of those who’ve deserialized before.</p>
<h2 id="serde-slayer-of-boilerplate"><a class="header" href="#serde-slayer-of-boilerplate">Serde, Slayer of Boilerplate</a></h2>
<p>The excellent <a href="https://serde.rs"><code>serde</code></a> crate is a framework for <strong>ser</strong>ializing and <strong>de</strong>serializing data across a variety of formats. We can use serde to annotate the above struct declaration, then build these structs from a CSV without all the verbose error checking and field assignment code.</p>
<header class="codeblock-header">Declarative Processing with Serde</header>
<pre><code class="language-rust">#[derive(serde::Deserialize)]
struct CreekSegment {
  creek_name: String,

  // serde offers some customizations so that we can use sensible
  // names in our code without having to modify our source data, whose
  // names we might not control.
  #[serde(rename = &quot;inf1&quot; )]
  infrastructure_label: String,

  // serde has built-in support for common data types like numbers and strings,
  // and it also allows other crates (like `wkt`) to build custom deserializers
  // so that we can create complex data types (like this `Geometry`)
  // directly from our input data.
  #[serde(deserialize_with = &quot;wkt::deserialize_wkt&quot;)]
  geometry: geo::geometry::Geometry
}
</code></pre>
<div class="callout rust-callout">
<h2 id="attributes-in-rust"><a class="header" href="#attributes-in-rust">Attributes in Rust</a></h2>
<p>In the above Rust code, the <code>#[...]</code> bits are called <em>attributes</em>. The <a href="https://doc.rust-lang.org/reference/attributes.html">official Rust documentation on attributes</a> is a little long in the tooth, but that’s because attributes are really powerful and can be used for a lot of different things. At the risk of oversimplifying, attributes are just a way to give pieces of code extra behavior. In this case, by annotating our struct with <code>#[derive(serde::Deserialize)]</code>, we give our struct the ability to be built from a .csv file or other serde data sources. We then tweak the way that serde will build our struct with the serde-specific <code>#[serde(...)]</code> attributes.</p>
</div>
<h2 id="keeping-it-tidy"><a class="header" href="#keeping-it-tidy">Keeping It Tidy</a></h2>
<p>Finally, before we return to our example, a struct like this is also the perfect place to hang some little helper methods:</p>
<header class="codeblock-header">Organizing Our Code with Struct Helper Methods</header>
<pre><code class="language-rust"><span class="boring">#[derive(serde::Deserialize)]
</span><span class="boring">struct CreekSegment {
</span><span class="boring">  creek_name: String,
</span><span class="boring">
</span><span class="boring">  #[serde(rename = &quot;inf1&quot; )]
</span><span class="boring">  infrastructure_label: String,
</span><span class="boring">
</span><span class="boring">  #[serde(deserialize_with = &quot;wkt::deserialize_wkt&quot;)]
</span><span class="boring">  geometry: geo::geometry::Geometry
</span><span class="boring">}
</span><span class="boring">
</span>impl CreekSegment {
  fn is_bridge(&amp;self) -&gt; bool {
    self.infrastructure_label == &quot;Bridged&quot;
  }

  fn centroid(&amp;self) -&gt; geo::Point {
    use geo::algorithm::Centroid;
    self.geometry.centroid().expect(&quot;a centroid exists for any non-empty geometry&quot;)
  }

  fn is_acceptable_size(&amp;self) -&gt; bool {
     // We're not intested in walking across large automobile bridges.
     self.square_meters() &lt; 250.0
  }

  fn square_meters(&amp;self) -&gt; f64 {
    use geo::algorithm::Area;
    use proj::Transform;

    // In the previous article about projections, we learned how to transform lat/lon to a local
    // projection to get useful area calculations.
    //
    // WGS84 - World Geodetic System, aka lat/lon
    // EPSG:3364 - NAD83(HARN) / Pennsylvania South (meters)
    let geometry_in_meters = self.geometry.transformed_crs_to_crs(&quot;WGS84&quot;, &quot;EPSG:3364&quot;).expect(&quot;valid transformation&quot;);
    geometry_in_meters.unsigned_area()
  }
}
</code></pre>
<p>Let’s see how we can use the above code to clean up our earlier implementation:</p>
<header class="codeblock-header">Processing a CSV with Serde</header>
<pre><code class="language-rust"><span class="boring">use csv;
</span><span class="boring">use geo::algorithm::Area;
</span><span class="boring">use geo::geometry::{Point, Geometry};
</span><span class="boring">use wkt;
</span><span class="boring">
</span><span class="boring">#[derive(serde::Deserialize)]
</span><span class="boring">struct CreekSegment {
</span><span class="boring">  creek_name: String,
</span><span class="boring">
</span><span class="boring">  #[serde(rename = &quot;inf1&quot; )]
</span><span class="boring">  infrastructure_label: String,
</span><span class="boring">
</span><span class="boring">  #[serde(deserialize_with = &quot;wkt::deserialize_wkt&quot;)]
</span><span class="boring">  geometry: geo::geometry::Geometry
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl CreekSegment {
</span><span class="boring">  fn is_bridge(&amp;self) -&gt; bool {
</span><span class="boring">    self.infrastructure_label == &quot;Bridged&quot;
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn centroid(&amp;self) -&gt; geo::Point {
</span><span class="boring">    use geo::algorithm::Centroid;
</span><span class="boring">    self.geometry.centroid().expect(&quot;a centroid exists for any non-empty geometry&quot;)
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn is_acceptable_size(&amp;self) -&gt; bool {
</span><span class="boring">     // We're not intested in walking across large automobile bridges.
</span><span class="boring">     self.square_meters() &lt; 250.0
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn square_meters(&amp;self) -&gt; f64 {
</span><span class="boring">    use geo::algorithm::Area;
</span><span class="boring">    use proj::Transform;
</span><span class="boring">
</span><span class="boring">    // In the previous article about projections, we learned how to transform lat/lon to a local
</span><span class="boring">    // projection to get useful area calculations.
</span><span class="boring">    //
</span><span class="boring">    // WGS84 - World Geodetic System, aka lat/lon
</span><span class="boring">    // EPSG:3364 - NAD83(HARN) / Pennsylvania South (meters)
</span><span class="boring">    let geometry_in_meters = self.geometry.transformed_crs_to_crs(&quot;WGS84&quot;, &quot;EPSG:3364&quot;).expect(&quot;valid transformation&quot;);
</span><span class="boring">    geometry_in_meters.unsigned_area()
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">let mut feature_reader = {
</span><span class="boring">  use std::fs::File;
</span><span class="boring">  let file = File::open(&quot;src/data/philly_waterways/philly_waterways.csv&quot;).expect(&quot;file path must be valid&quot;);
</span><span class="boring">  csv::Reader::from_reader(file)
</span><span class="boring">};
</span><span class="boring">
</span>let mut acceptable_walkabout_bridges: Vec&lt;CreekSegment&gt; = vec![];

for record in feature_reader.deserialize() {

  // All of our error checking and field parsing can be replaced by
  // a single line. The rest is automatically inferred from our
  // serde-annotated struct declaration.
  let creek_segment: CreekSegment = record.expect(&quot;creek segment must be valid&quot;);

  // At this point we know all the fields of creek_segment
  // have been populated.

  // We're only interested in Bridged segments.
  if !creek_segment.is_bridge() {
    continue;
  }

  // We're only interested in bridges that cross Wissahickon Creek.
  if creek_segment.creek_name != &quot;Wissahickon Creek&quot; {
    continue;
  }

  // Ok, we've utilized some attributes to narrow our search,
  // now let's dig deeper with some geometric analysis.

  let bridge_centroid = creek_segment.centroid();

  // We're only interested in the part of the Wissahickon Creek that's within
  // the Wissahickon Valley Park.
  let SOUTHERN_PARK_BORDER = 40.013214;
  let NORTHERN_PARK_BORDER = 40.084306;
  if bridge_centroid.y() &lt; SOUTHERN_PARK_BORDER || bridge_centroid.y() &gt; NORTHERN_PARK_BORDER {
    continue;
  }

  // We're not intested in walking across large automobile bridges.
  if !creek_segment.is_acceptable_size() {
    continue;
  }

  // Using attribute data and geometric processing, we've identified a good walking bridge!
  acceptable_walkabout_bridges.push(creek_segment);
}

<span class="boring">assert_eq!(acceptable_walkabout_bridges.len(), 8);
</span><span class="boring">approx::assert_relative_eq!(acceptable_walkabout_bridges[3].centroid(), Point::new(-75.22563703858332, 40.071892693259315));
</span></code></pre>
<p>Using serde and structs like this is completely optional, but it can help keep your code tidy — especially as programs get more complex. If you prefer the ad-hoc style of the original example (e.g. accessing fields by number) and you don’t care about adding any cute little helper methods, that’s totally fine. Even if you aren’t doing calculations on rivers, just go with the flow.</p>
<h2 id="csv-u-l8r"><a class="header" href="#csv-u-l8r">CSV U L8R</a></h2>
<p>CSV files can feel charmingly anachronistic, like a weird antique tool that sometimes still works surprisingly well. Tons of programs can read and write CSV files, and you can quickly and easily examine their contents in any spreadsheet app. However, this simplicity often comes at a price, and the limitations of the format are not always immediately obvious.</p>
<p>For example, when someone sends you a CSV file that contains geographic data, the layout is always kind of a new mystery to be solved. There is no strong convention for the way its columns will be named, where they will be positioned, or how its geometry will be represented. Although WKT is common, it’s far from universal: A CSV of points, for instance, will sometimes include two <code>latitude</code> and <code>longitude</code> columns instead of a single WKT column.</p>
<p>Another problem with CSV files is that it’s not always clear what type of information is in a column:</p>
<div class="table-wrapper"><table><thead><tr><th>phone</th><th>description</th></tr></thead><tbody>
<tr><td>311</td><td>info</td></tr>
<tr><td>911</td><td>emergency</td></tr>
<tr><td>…</td><td>…</td></tr>
<tr><td>1-818-912-8200 ext. 4</td><td>office</td></tr>
</tbody></table>
</div>
<p>Unless you examine the entire list in advance, you might not realize that <code>phone</code> is a text column, not a numeric one. Some formats are always clear about the distinction between numbers and text, but CSV isn’t one of them.</p>
<p>This lack of standardization means that whenever you encounter geographic data stored in a CSV, first you have to dig around a bit to orient yourself and figure out how to align your program with the CSV author’s conventions.</p>
<h2 id="omgeojson"><a class="header" href="#omgeojson">OMGeoJSON</a></h2>
<p><a href="https://geojson.org/">GeoJSON</a> is another available format for representing geospatial features (geometry + data) with a different set of trade-offs. Seeing is believing, so here’s how some of our previous data could be structured in GeoJSON:</p>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;FeatureCollection&quot;,
  &quot;features&quot;: [
    {
      &quot;type&quot;: &quot;Feature&quot;,
      &quot;properties&quot;: {
        &quot;creek_name&quot;: &quot;Haines-Dittingers Creek&quot;,
        &quot;inf1&quot;: &quot;Impoundment&quot;
      },
      &quot;geometry&quot;: {
        &quot;type&quot;: &quot;Polygon&quot;,
        &quot;coordinates&quot;: [
          [
            [
              -75.2512163863237,
              40.2171158853747
            ],
            [
              -75.2512026232353,
              40.217108225299
            ],
            [
              -75.2511416958994,
              40.2170817213073
            ],
            ...
          ]
        ]
      }
    },
    {
      &quot;type&quot;: &quot;Feature&quot;,
      &quot;properties&quot;: {
        &quot;creek_name&quot;: &quot;Wissahickon Creek&quot;,
        &quot;inf1&quot;: &quot;Bridged&quot;
      },
      &quot;geometry&quot;: {
        &quot;type&quot;: &quot;Polygon&quot;,
        &quot;coordinates&quot;: [
          [
            [
              -75.25461361296729,
              40.1820761530732
            ],
            [
              -75.2545303055114,
              40.1819601471794
            ],
            [
              -75.25446431085831,
              40.1820297432309
            ],
            ...
          ]
        ]
      }
    },
    ...
}
</code></pre>
<p>GeoJSON is pretty popular, especially for mapping and other geospatial applications on the web. This is largely because it’s an extension of <a href="https://en.wikipedia.org/wiki/JSON">JSON</a>, which is a format that web browsers already use extensively for all kinds of information. That makes it easy for web programmers to manipulate GeoJSON using JavaScript in the browser.</p>
<p>However, GeoJSON has long since left the domain of “web-only” formats, and now many other geospatial tools know how to handle it too: <a href="https://qgis.org">QGIS</a>, <a href="https://libgeos.org/">GEOS</a>, <a href="https://locationtech.github.io/jts/">JTS</a>, <a href="https://gdal.org/">GDAL</a>, and <a href="https://github.com/shapely/shapely">Shapely</a> are all fluent in GeoJSON.</p>
<p>Let’s run our Wissahickon calculations again, only this time using information structured in GeoJSON format instead of a CSV. What’s nice about using serde, is just how little of our code actually needs to change to support this completely different encoding:</p>
<header class="codeblock-header">Process GeoJSON with Serde</header>
<pre><code class="language-rust"><span class="boring">use csv;
</span><span class="boring">use geo::algorithm::Area;
</span><span class="boring">use geo::geometry::{Point, Geometry};
</span><span class="boring">use wkt;
</span><span class="boring">
</span>#[derive(serde::Deserialize)]
struct CreekSegment {
   creek_name: String,

   #[serde(rename = &quot;inf1&quot; )]
   infrastructure_label: String,

   // #[serde(deserialize_with = &quot;wkt::deserialize_wkt&quot;)]
   #[serde(deserialize_with = &quot;geojson::deserialize_geometry&quot;)]
   geometry: geo::geometry::Geometry
}

<span class="boring">impl CreekSegment {
</span><span class="boring">  fn is_bridge(&amp;self) -&gt; bool {
</span><span class="boring">    self.infrastructure_label == &quot;Bridged&quot;
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn centroid(&amp;self) -&gt; geo::Point {
</span><span class="boring">    use geo::algorithm::Centroid;
</span><span class="boring">    self.geometry.centroid().expect(&quot;a centroid exists for any non-empty geometry&quot;)
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn is_acceptable_size(&amp;self) -&gt; bool {
</span><span class="boring">     // We're not intested in walking across large automobile bridges.
</span><span class="boring">     self.square_meters() &lt; 250.0
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn square_meters(&amp;self) -&gt; f64 {
</span><span class="boring">    use geo::algorithm::Area;
</span><span class="boring">    use proj::Transform;
</span><span class="boring">
</span><span class="boring">    // In the previous article about projections, we learned how to transform lat/lon to a local
</span><span class="boring">    // projection to get useful area calculations.
</span><span class="boring">    //
</span><span class="boring">    // WGS84 - World Geodetic System, aka lat/lon
</span><span class="boring">    // EPSG:3364 - NAD83(HARN) / Pennsylvania South (meters)
</span><span class="boring">    let geometry_in_meters = self.geometry.transformed_crs_to_crs(&quot;WGS84&quot;, &quot;EPSG:3364&quot;).expect(&quot;valid transformation&quot;);
</span><span class="boring">    geometry_in_meters.unsigned_area()
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span>let mut feature_reader = {
  use std::fs::File;
  let file = File::open(&quot;src/data/philly_waterways/philly_waterways.geojson&quot;).expect(&quot;file path must be valid&quot;);
  // csv::Reader::from_reader(file)
  geojson::FeatureReader::from_reader(file)
};

let mut acceptable_walkabout_bridges: Vec&lt;CreekSegment&gt; = vec![];

for record in feature_reader.deserialize().expect(&quot;valid feature collection&quot;) {

  // Thanks to the magic of serde, the rest of this example is exactly
  // the same as the serde CSV example above!
  //
  // We've hidden it for brevity, but you can see the rest of the code if you click
  // the &quot;eyeball&quot; icon in the top right corner of this code block.

  // ...

<span class="boring">  // All of our error checking and field parsing can be replaced by
</span><span class="boring">  // a single line. The rest is automatically inferred from our
</span><span class="boring">  // serde-annotated struct declaration.
</span><span class="boring">  let creek_segment: CreekSegment = record.expect(&quot;creek segment must be valid&quot;);
</span><span class="boring">
</span><span class="boring">  // At this point we know all the fields of creek_segment
</span><span class="boring">  // have been populated.
</span><span class="boring">
</span><span class="boring">  // We're only interested in Bridged segments.
</span><span class="boring">  if !creek_segment.is_bridge() {
</span><span class="boring">    continue;
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  // We're only interested in bridges that cross Wissahickon Creek.
</span><span class="boring">  if creek_segment.creek_name != &quot;Wissahickon Creek&quot; {
</span><span class="boring">    continue;
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  // Ok, we've utilized some attributes to narrow our search,
</span><span class="boring">  // now let's dig deeper with some geometric analysis.
</span><span class="boring">
</span><span class="boring">  let bridge_centroid = creek_segment.centroid();
</span><span class="boring">
</span><span class="boring">  // We're only interested in the part of the Wissahickon Creek that's within
</span><span class="boring">  // the Wissahickon Valley Park.
</span><span class="boring">  let SOUTHERN_PARK_BORDER = 40.013214;
</span><span class="boring">  let NORTHERN_PARK_BORDER = 40.084306;
</span><span class="boring">  if bridge_centroid.y() &lt; SOUTHERN_PARK_BORDER || bridge_centroid.y() &gt; NORTHERN_PARK_BORDER {
</span><span class="boring">    continue;
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  // We're not intested in walking across large automobile bridges.
</span><span class="boring">  if !creek_segment.is_acceptable_size() {
</span><span class="boring">    continue;
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  // Using attribute data and geometric processing, we've identified a good walking bridge!
</span>  acceptable_walkabout_bridges.push(creek_segment);
}

assert_eq!(acceptable_walkabout_bridges.len(), 8);
approx::assert_relative_eq!(acceptable_walkabout_bridges[3].centroid(), Point::new(-75.22563703858332, 40.071892693259315));
</code></pre>
<h2 id="straying-from-the-format"><a class="header" href="#straying-from-the-format">Straying from the Format</a></h2>
<p>Ubiquity is arguably GeoJSON’s biggest upside, but it’s not the perfect format for everything. </p>
<p><img src="images/philly-sinkhole-dump-truck.jpg" alt="Dump truck on the street, whose read wheel has fallen into a sinkhole" />
<span class="photo-credit">Photo via <a href="https://twitter.com/orentalks/status/1070372166867320832">@orentalks</a></span></p>
<p>Like a truck on its way to fix a sinkhole (but then falling into another sinkhole before it can get there), it’s good to be aware of a few potential pitfalls in advance.</p>
<p>If you scroll up to the GeoJSON sample above, you may notice that the way it represents geometry is quite verbose. Unlike WKT, it’s not as easy for humans to read at a glance, and compared to some other formats, it’s not very efficient for computers to store or transmit. JSON editors exist, but they aren’t nearly as powerful or widespread as spreadsheet programs that can easily read CSVs. GeoJSON also lacks a <em>spatial index</em> (future topic!) so certain operations on complex geometries are slow.</p>
<p>There’s an entire world of alternative formats available — each with their own set of trade-offs. Luckily, Rust has support for pretty much all of them at this point. Aside from <a href="https://docs.rs/wkt">WKT</a> and <a href="https://docs.rs/geojson">GeoJSON</a>, other popular choices include:</p>
<ul>
<li><a href="https://docs.rs/shapefile">Shapefiles (.shp)</a> - A venerable (and often maligned) all-purpose format.</li>
<li><a href="https://docs.rs/geozero">Geopackage (.gpx)</a> - The “preferred” format for lots of desktop GIS applications these days, built on top of <a href="https://www.sqlite.org">SQLite</a>.</li>
<li><a href="https://docs.rs/flatgeobuf">Flatgeobuf (.fgb)</a> - A newer format that is well-suited for efficient and random read-only access.</li>
</ul>
<h2 id="give-yourself-some-space"><a class="header" href="#give-yourself-some-space">Give Yourself Some Space</a></h2>
<p>Up next, we’ll learn how to combine attributes across multiple data sources using <em>spatial joins</em>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="youre-projecting.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="join-the-party.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="youre-projecting.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="join-the-party.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
