<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Geospatial Rust</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/css/style.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded affix "><li class="part-title">Lessons</li><li class="chapter-item expanded "><a href="youre-projecting.html"><strong aria-hidden="true">2.</strong> You're Projecting</a></li><li class="chapter-item expanded "><a href="feature-creek.html"><strong aria-hidden="true">3.</strong> Feature Creek</a></li><li class="chapter-item expanded "><a href="join-the-party.html"><strong aria-hidden="true">4.</strong> Join the Party</a></li><li class="chapter-item expanded affix "><li class="part-title">About This Book</li><li class="chapter-item expanded "><a href="contact.html"><strong aria-hidden="true">5.</strong> Contact the Authors</a></li><li class="chapter-item expanded "><a href="license.html"><strong aria-hidden="true">6.</strong> License</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Geospatial Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <img alt="A globe surrounded by the signature Rust gear - the GeoRust logo" src="images/georust.png" style="display: block; margin-left: auto; margin-right: auto; width: 40%;" />
<h1 id="geospatial-rust-the-process"><a class="header" href="#geospatial-rust-the-process">Geospatial: Rust the Process</a></h1>
<p>Luke Skywalker once said that space is the final frontier, like it’s just some distant concept far, far away. Set your lightsaber to stun just for a second though, and you quickly realize that space is vast and ever-present — it’s all around us and between everything everywhere. It’s familiar, yet elusive. How big is it? What should we do with it? Are we there yet?</p>
<h2 id="what-is-geospatial-computation"><a class="header" href="#what-is-geospatial-computation">What Is Geospatial Computation?</a></h2>
<p>If a computer is answering questions about maps, congratulations! That’s geospatial computation.</p>
<p>OK, maybe that’s an oversimplification — but it’s not <em>so</em> far off.</p>
<p>Unlike a lot of abstract things that happen with computers (e.g. seeing “#nofilter” on a sepia-toned photo of someone with cartoon cat ears), the results of geospatial work can be tied back to the real world. Transportation planners use precise measurements to start building new roads to make traffic better in the future, while present-day commuters use map apps to navigate around the absolute chaos those planners have caused. Climate scientists measure rising ocean levels, while Florida real-estate agents measure the availability of brand-new oceanfront condos. Hikers at home dream about getting lost in the wilderness, while hikers lost in the wilderness dream about finding a way home.</p>
<p>No matter what your agenda is, information is power, and all kinds of people are using geospatial techniques to go places. It can be an exciting field indeed.</p>
<h2 id="why-rust"><a class="header" href="#why-rust">Why Rust?</a></h2>
<p>Nobody likes to be lost for long; Rust is extremely fast. For millennia, maps have acted as a form of shared memory to safely access stored locations; Rust can help you ensure that shared map locations stored in memory are also <a href="https://doc.rust-lang.org/nomicon/meet-safe-and-unsafe.html">accessed safely</a>. People really love discovering new places; people also <a href="https://insights.stackoverflow.com/survey/2021#technology-most-loved-dreaded-and-wanted">really love Rust</a>.</p>
<p>Whether you are interested in Rust for its performance or security, integrating geospatial data with Rust is a natural combination.</p>
<h2 id="who-is-this-book-for"><a class="header" href="#who-is-this-book-for">Who Is This Book For?</a></h2>
<p>If you’re new to the geospatial field, welcome aboard! The examples that follow are not intended to be a comprehensive introduction to the field of geospatial analysis, but all of them were designed to be approachable by anyone with an interest in learning more. There should be just enough context for you to get your bearings, but feel free to explore some side quests before coming back to the main story.</p>
<p>If you’ve previously done some geospatial analysis in another environment but are new to the Rust programming language, hello neighbor! Feel free to jump around or skip ahead to the well-labeled examples, which give real solutions to practical problems.</p>
<p>In any case, the path of your life has led you here: the right place to get started. This set of examples will help you navigate familiar geospatial problems using a powerful programming language that may not quite be familiar to you yet.</p>
<p>So feel free to <a href="https://www.rust-lang.org/learn/get-started">install Rust</a>; make yourself a latte (with or without Java); pick any topic on the left; and follow the <a href="https://docs.qgis.org/2.18/en/docs/gentle_gis_introduction/coordinate_reference_systems.html">Coordinate Reference System</a> of your own heart as we dive headfirst into common geospatial questions and learn how to use computers to efficiently find the answers. 🖖🤖</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="youre-projecting"><a class="header" href="#youre-projecting">You’re Projecting</a></h1>
<p>Just like any good argument, the best way to start spatial analysis is by projecting your points.</p>
<p>Speaking of good arguments, <em>almost</em> everyone agrees at this point that the earth is a three-dimensional (and slightly smooshed) sphere. However, many spatial algorithms operate under the rustic assumptions of two-dimensional <a href="https://en.wikipedia.org/wiki/Euclidean_geometry">euclidean geometry</a>. When your input is defined in terms of latitude and longitude, the first step is to flatten (or “project”) it onto 2D space.</p>
<h2 id="in-depth-perception"><a class="header" href="#in-depth-perception">In-depth Perception</a></h2>
<p>There are lots of ways to flatten a 3D thing into a 2D space, but this process inherently introduces some distortion (like an orange getting smashed in your backpack). Choosing the best possible “projection” for a given scenario is part of the art of being a geospatial analyst.</p>
<div class="side-by-side">
  <div>
    <img src="images/mercator-projection.jpg" alt="A map of the earth as projected to a rectangle with the Mercator projection." />
    <center><strong>Mercator</strong></center>
  </div>
<div>
    <img src="images/gnomonic-projection.jpg" alt="A map of the northern hemisphere of earth centered on the North Pole, projected to a circle with a gnomonic projection" />
    <center><strong>Gnomonic</strong></center>
  </div>
</div>
<p>For applications spanning the globe, <a href="https://en.wikipedia.org/wiki/Mercator_projection">the mercator projection</a> is a common projection that minimizes distortion for most of the inhabited planet. However, if you’re focused on relative distance from a particular point, a <a href="https://en.wikipedia.org/wiki/Gnomonic_projection">gnomonic projection</a> might be a better choice.</p>
<p>If your work is more local in nature, you can use a projection method that is finely tuned for high accuracy within a relatively small and specific geographic area like <a href="https://www.conservation.ca.gov/cgs/rgm/state-plane-coordinate-system#zone5">Zone 5 in Southern California</a>, but if you try to use that same projection for something in <a href="https://en.wikipedia.org/wiki/New_York_City">New York</a> (or, <em>alas and alack</em>, <a href="https://en.wikipedia.org/wiki/York">old York</a>) your results will be way off!</p>
<p>Everything about this would be easier if the flat-earthers were right, but fortunately there are several well-rounded tools for our mostly-round earth.</p>
<h2 id="co-dependency"><a class="header" href="#co-dependency">Co-Dependency</a></h2>
<p>Our first group project(ion) will require some new dependencies.</p>
<p>The <a href="https://proj.org">PROJ</a> coordinate transformation software has been helping people solve geospatial problems since the late 1970’s. In addition to its longevity, it also stands out for its accuracy and speed. The <a href="https://crates.io/crates/proj">proj crate</a> wraps and extends PROJ to make it feel right at home in your Rust application.</p>
<p>For its part, <a href="https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry">well-known text</a> (WKT) is a very (sigh) well-known way of representing geometry as text, and the <a href="https://crates.io/crates/wkt">wkt crate</a> adds read and write support for WKT to Rust.</p>
<p>Finally, we’ll be using the <a href="https://crates.io/crates/geo">geo crate</a> (a collection of geometry types and algorithms) to do some analysis.</p>
<p>Let’s add these dependencies to our <code>Cargo.toml</code> file and get started:</p>
<pre><code class="language-toml ignore">[dependencies]
geo = &quot;0.21.0&quot;
proj = &quot;0.27.0&quot;
wkt = &quot;0.10.3&quot;
</code></pre>
<p>OK, now let’s look for a body of water and dive right in.</p>
<p><img src="images/ivanhoe-point.png" alt="Point in the center of the Ivanhoe reservoir in Los Angeles" /></p>
<p>This is the Ivanhoe reservoir in Los Angeles. Named after Sir Walter Scott’s <em>Ivanhoe</em>, a stirring tale of romance and chivalry first published in 1819…</p>
<h3 id="just-get-to-the-point"><a class="header" href="#just-get-to-the-point">Just Get to the Point</a></h3>
<p>OK OK OK. We can use the <code>wkt</code> crate to create a <code>geo</code> geometry from the text representation of this point in the center of the water.</p>
<header class="codeblock-header">Parse WKT</header>
<pre><code class="language-rust">use geo::Point;
use wkt::TryFromWkt;

let wkt_string = &quot;POINT(-118.265429 34.103175)&quot;;
let mut point: Point = Point::try_from_wkt_str(wkt_string).unwrap();
assert_eq!(point.x(), -118.265429);
assert_eq!(point.y(), 34.103175);
</code></pre>
<div class="callout rust-callout">
<h3 id="personality-traits"><a class="header" href="#personality-traits">Personality Traits</a></h3>
<p>Let’s focus on this bit of code from the example above: <code>Point::try_from_wkt_str</code>.</p>
<p>The <a href="https://docs.rs/geo/latest/geo/struct.Point.html"><code>Point</code></a> type, from the <strong><code>geo</code></strong> crate, calls the <a href="https://docs.rs/wkt/latest/wkt/trait.TryFromWkt.html"><code>try_from_wkt_str</code></a> method, from the <strong><code>wkt</code></strong> crate. Depending on your personality and background, this kind of cross-library interaction may feel either completely horrifying or utterly unremarkable. Many languages, like C++ or Java, don’t really support adding methods to existing types like this, but more dynamic languages, like Ruby or Python, let you easily do all kinds of fun things like replacing or adding methods at runtime.</p>
<p>However, ultimately you reap what you sow. Unintentionally clobbering some existing method definition that was defined in a third-party module can quickly make “fun things” feel decidedly less fun. For that reason, even when they are supported, people often try to avoid these kinds of language gymnastics.</p>
<p>Rust tries to take an enlightened middle ground with its trait system. Rust supports adding shared functionality to existing types, but only in some <em>carefully</em> prescribed ways which avoid many of the problems with less-restrictive approaches. Rust’s trait system is a core component of the language, and you can (and should!) read more about it in the <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">official documentation</a>.</p>
<p>The main takeaway for now is this: <strong>In Rust, functionality is often defined in terms of traits</strong> and in order to be effective you’ll need to <code>use</code> both the <em>traits</em> and the <em>types</em> which implement those traits (in this case <code>use wkt::TryFromWkt</code> and <code>use geo::Point</code> respectively).</p>
</div>
<h2 id="trait-or"><a class="header" href="#trait-or">Trait-or</a></h2>
<p>Another useful trait is the <a href="https://docs.rs/proj/latest/proj/trait.Transform.html"><code>Transform</code></a> trait, provided by the <code>proj</code> crate, which can be used to project geometries into a different <a href="https://en.wikipedia.org/wiki/Spatial_reference_system">coordinate reference system</a>.</p>
<p>Let’s betray latitude and longitude, technically known as <a href="https://en.wikipedia.org/wiki/World_Geodetic_System"><em>The World Geodetic System</em></a>, and transform our point in the center of the Ivanhoe reservoir to the <a href="https://www.conservation.ca.gov/cgs/rgm/state-plane-coordinate-system">California State Plane Coordinate System</a>.</p>
<header class="codeblock-header">Transform a Point with PROJ</header>
<pre><code class="language-rust"><span class="boring">use geo::Point;
</span><span class="boring">use wkt::TryFromWkt;
</span><span class="boring">
</span><span class="boring">let wkt_string = &quot;POINT(-118.265429 34.103175)&quot;;
</span><span class="boring">let mut point: Point = Point::try_from_wkt_str(wkt_string).unwrap();
</span><span class="boring">
</span>use proj::Transform;

// Transform from WGS84 to EPSG:6423
// https://epsg.io/6423 - California zone 5 (meters)
point.transform_crs_to_crs(&quot;WGS84&quot;, &quot;EPSG:6423&quot;).unwrap();

assert_eq!(point.x(), 1975508.4666086377);
assert_eq!(point.y(), 566939.9943794473);
</code></pre>
<p>If we want to export or share our results, the <code>wkt</code> crate can serialize a point’s in-memory representation back to well-known text.</p>
<header class="codeblock-header">Output WKT</header>
<pre><code class="language-rust"><span class="boring">use geo::Point;
</span><span class="boring">use wkt::TryFromWkt;
</span><span class="boring">
</span><span class="boring">let wkt_string = &quot;POINT(-118.265429 34.103175)&quot;;
</span><span class="boring">let mut point: Point = Point::try_from_wkt_str(wkt_string).unwrap();
</span><span class="boring">
</span><span class="boring">use proj::Transform;
</span><span class="boring">
</span><span class="boring">// Transform from WGS84 to EPSG:6423
</span><span class="boring">// https://epsg.io/6423 - California zone 5 (meters)
</span><span class="boring">point.transform_crs_to_crs(&quot;WGS84&quot;, &quot;EPSG:6423&quot;).unwrap();
</span><span class="boring">
</span>use wkt::ToWkt;
let wkt_output = point.wkt_string();

assert_eq!(wkt_output, &quot;POINT(1975508.4666086377 566939.9943794473)&quot;);
</code></pre>
<h3 id="connect-the-dots"><a class="header" href="#connect-the-dots">Connect the Dots</a></h3>
<p>Projecting a single point is simple enough. Let’s try something a little more interesting.</p>
<p><img src="images/ivanhoe-outline.png" alt="Polygon around the Ivanhoe reservoir in Los Angeles" /></p>
<p>People often say that the best way to learn is by making a mistake, so follow along as we do exactly that when calculating the area of this reservoir.</p>
<header class="codeblock-header">Compute Area the Wrong Way</header>
<pre><code class="language-rust">use geo::Polygon;
use wkt::TryFromWkt;
use geo::algorithm::area::Area;

let wkt_polygon = &quot;POLYGON((-118.2662232 34.1038592,-118.2662339 34.1023485,-118.2639303 34.1023235,-118.2649125 34.1038878))&quot;;
let mut polygon: Polygon = Polygon::try_from_wkt_str(wkt_polygon).unwrap();

// 🤔 That's a suspiciously small number for so much water.
assert_eq!(polygon.unsigned_area(), 0.000002779367475015937);
</code></pre>
<p>Ivanhoe reservoir is large enough to hold over 400,000 <a href="https://en.wikipedia.org/wiki/Shade_balls">shade balls</a>, so any area measurement that begins with <code>0.00000...</code> is highly suspect. Because our polygon was described in degrees (unprojected coordinates), the units of area we just computed are in “square degrees” which is not a very useful measurement. A degree near the North Pole is very different from a degree near the equator (and not just in terms of temperature).</p>
<p>To get a reasonable result, we should first project the polygon to a euclidean coordinate reference system that is suitable for Los Angeles.</p>
<header class="codeblock-header">Compute Area the Right Way</header>
<pre><code class="language-rust"><span class="boring">use geo::Polygon;
</span><span class="boring">use wkt::TryFromWkt;
</span><span class="boring">use geo::algorithm::area::Area;
</span><span class="boring">
</span><span class="boring">let wkt_polygon = &quot;POLYGON((-118.2662232 34.1038592,-118.2662339 34.1023485,-118.2639303 34.1023235,-118.2649125 34.1038878))&quot;;
</span><span class="boring">let mut polygon: Polygon = Polygon::try_from_wkt_str(wkt_polygon).unwrap();
</span><span class="boring">
</span>use proj::Transform;
// Transform from WGS84 to EPSG:6423
// https://epsg.io/6423 - California zone 5 (meters)
polygon.transform_crs_to_crs(&quot;WGS84&quot;, &quot;EPSG:6423&quot;).unwrap();

// Now we can get a useful &quot;square meters&quot; measurement.
assert_eq!(polygon.unsigned_area().round(), 28447.0);
</code></pre>
<p>Notice that we can transform this polygon the same way we previously transformed a single point. Now we know that approximately 28.4k square meters are required to hold 400k floating spheres in one small spot on the floating (slightly smooshed) sphere we call home, and we’ve solved a story problem that we were never even asked.</p>
<h2 id="working-with-what-youve-got"><a class="header" href="#working-with-what-youve-got">Working with What You’ve Got</a></h2>
<p>That’s a quick look at some of the basics of working with geometry in Rust. Next, we’ll take a look at how to use file formats like CSV and GeoJSON that support <em>features</em> to go beyond just the shape of things.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="feature-creek"><a class="header" href="#feature-creek">Feature Creek</a></h1>
<p>In the <a href="./youre-projecting.html">previous chapter</a> we worked with geometry stored in Well Known Text (WKT) format. It should come as no surprise that solving geospatial problems fundamentally involves geometry, but it’s rarely <em>exclusively</em> about geometry. Usually there are other attributes associated with that geometry that we also want to explore. This combination of a geometry with its associated attribute data is often referred to as a <em>feature</em>, and a group of features can be called a <em>feature collection</em>.</p>
<p><img src="images/philly-waterways.png" alt="Many spidering waterways consolidating into a major river" /></p>
<p>In addition to being the “City of Brotherly Love,” Philadelphia is also a city of water. We can describe shapes using Well Known Text, and all these waterways can be represented as a long list of WKT declarations:</p>
<ul>
<li><code>MULTIPOLYGON(....)</code></li>
<li><code>MULTIPOLYGON(....)</code></li>
<li><code>MULTIPOLYGON(....)</code></li>
<li>…</li>
</ul>
<h2 id="cry-me-a-rivers"><a class="header" href="#cry-me-a-rivers">Cry Me a River(s)</a></h2>
<p>You can say “I’m going for a walk down by <em>the</em> river” if you live in a one-river town, but in Philadelphia you need to be a little more specific. Let’s associate a name with each of these shapes to clarify which river we’re talking about.</p>
<div class="table-wrapper"><table><thead><tr><th>creek_name</th><th>geometry</th></tr></thead><tbody>
<tr><td>Wissahickon Creek</td><td>MULTIPOLYGON(….)</td></tr>
<tr><td>Schuylkill River</td><td>MULTIPOLYGON(….)</td></tr>
<tr><td>Delaware River</td><td>MULTIPOLYGON(….)</td></tr>
</tbody></table>
</div>
<p><img src="images/philly-waterways-labeled.png" alt="The many rivers of Philadelphia again, but with labels this time; the Delaware on the east, and the Schuylkill from the northwest" /></p>
<p>Now we’re talking specifics! The Delaware River defines Philadelphia’s eastern boundary, and the Schuylkill River runs through the city from the North West. Even though it’s not in very many spellcheck dictionaries, the Wissahickon is still a local favorite for urban walkers, so let’s amble over to the Wissahickon Valley Park.</p>
<h2 id="bridging-the-gap"><a class="header" href="#bridging-the-gap">Bridging the Gap</a></h2>
<p><img src="images/philly-wissahickon-valley-park.png" alt="Detail of the Wissahickon Creek" /></p>
<p>Walking <em>near</em> water is neat, and walking <strong>on</strong> water is an advanced topic for <a href="https://en.wikipedia.org/wiki/Bible">another book</a>, but walking <em>over</em> water? Now that’s an infrastructural thrill within reach! So how do we find which segments of the Wissahickon have a bridge? Combining a geometry with other associated data into a <em>feature</em> allows us to solve these kinds of problems.</p>
<p>There are a lot of ways we can represent geospatial information. Recall that well-known text (WKT) is only concerned with representing a shape — it can’t store whether that shape represents a bridge or has a name. One approach is to embed WKT into <em>another</em> more flexible format such as a CSV file, with one column containing WKT to describe the shape of the feature, and each additional column including another attribute, such as the name of the waterway or whether the segment has a bridge.</p>
<p><img src="images/philly-bridge-selected.png" alt="Zoomed in segment of a winding waterway, with one narrow segment highlighted" /></p>
<p>This <a href="data/philly_waterways/philly_waterways.csv">CSV of Philadelphia waterway segments</a> does just that. Here’s an excerpt:</p>
<div class="table-wrapper"><table><thead><tr><th>creek_name</th><th>inf1</th><th>geometry</th></tr></thead><tbody>
<tr><td>Cobbs Creek</td><td></td><td>MULTIPOLYGON(….)</td></tr>
<tr><td>Cobbs Creek</td><td>Bridged</td><td>MULTIPOLYGON(….)</td></tr>
<tr><td>Wise’s Mill</td><td></td><td>MULTIPOLYGON(….)</td></tr>
<tr><td>Wissahickon Creek</td><td>Bridged</td><td>MULTIPOLYGON(….)</td></tr>
<tr><td>Wissahickon Creek</td><td></td><td>MULTIPOLYGON(….)</td></tr>
<tr><td>Wissahickon Creek</td><td>Bridged</td><td>MULTIPOLYGON(….)</td></tr>
</tbody></table>
</div>
<p>You’ll notice that a single creek is broken into many small segments in this data set. A “Bridged” segment indicates precisely where that bridge exists on the waterway (highlighted yellow in the image above).</p>
<h2 id="the-short-list-a-bridged"><a class="header" href="#the-short-list-a-bridged">The Short List (A-bridged)</a></h2>
<p>To make a handout for our “First Annual Wissahickon Walkabout,” we want to include a list of bridges where participants can cross the Wissahickon. Some of these bridges are quite lovely, providing tourists an ideal location for selfies, while fly fishers cast shade while casting in the shade below.</p>
<p>Let’s combine a little attribute inspection with a little geometric processing to find the best bridges for our walk:</p>
<header class="codeblock-header">Process a CSV</header>
<pre><code class="language-rust">use csv;
use geo::algorithm::{Centroid, Area};
use geo::geometry::{Point, Geometry};
use proj::Transform;
use wkt;

let mut feature_reader = {
  use std::fs::File;
  let file = File::open(&quot;src/data/philly_waterways/philly_waterways.csv&quot;).expect(&quot;file path must be valid&quot;);
  csv::Reader::from_reader(file)
};

let mut acceptable_walkabout_bridges: Vec&lt;Point&gt; = vec![];

for row in feature_reader.records() {
  let creek_segment = row.expect(&quot;must be able to read row from CSV&quot;);

  let creek_name = creek_segment.get(0).expect(&quot;'creek_name' field must be present&quot;);
  let infrastructure_label = creek_segment.get(1).expect(&quot;'inf1' field must be present&quot;);
  let geometry_str = creek_segment.get(2).expect(&quot;`geometry` field must be present&quot;);

  // We're only interested in Bridged segments.
  if infrastructure_label != &quot;Bridged&quot; {
    continue;
  }

  // We're only interested in bridges that cross Wissahickon Creek.
  if creek_name != &quot;Wissahickon Creek&quot; {
    continue;
  }

  // Ok, we've utilized some attributes to narrow our search,
  // now let's dig deeper with some geometric analysis.

  use wkt::TryFromWkt;
  let geometry = Geometry::try_from_wkt_str(geometry_str).expect(&quot;wkt must be valid&quot;);

  let bridge_centroid = geometry.centroid().expect(&quot;a centroid should exist for any non-empty geometry&quot;);

  // We're only interested in the part of the Wissahickon Creek that's within
  // the Wissahickon Valley Park.
  let SOUTHERN_PARK_BORDER = 40.013214;
  let NORTHERN_PARK_BORDER = 40.084306;
  if bridge_centroid.y() &lt; SOUTHERN_PARK_BORDER || bridge_centroid.y() &gt; NORTHERN_PARK_BORDER {
    continue;
  }

  // Compute the size of the bridge
  let bridge_area = {
    // In the previous article about projections, we learned how to transform lat/lon to a local
    // projection to get useful area calculations.
    //
    // WGS84 - World Geodetic System, aka lat/lon
    // EPSG:3364 - NAD83(HARN) / Pennsylvania South (meters)
    let geometry_in_meters = geometry.transformed_crs_to_crs(&quot;WGS84&quot;, &quot;EPSG:3364&quot;).expect(&quot;valid transformation&quot;);
    geometry_in_meters.unsigned_area()
  };

  // We're not intested in walking across large automobile bridges.
  if bridge_area &gt; 250.0 {
    continue;
  }

  // Using attribute data and geometric processing, we've identified a good walking bridge!
  acceptable_walkabout_bridges.push(bridge_centroid);
}

assert_eq!(acceptable_walkabout_bridges.len(), 8);
approx::assert_relative_eq!(acceptable_walkabout_bridges[3], Point::new(-75.22563703858332, 40.071892693259315));
</code></pre>
<p>Eight bridges seems like the perfect number of crossings for an enthusiastic walk about the Wissahickon. These bridges run the gamut, including wee pedestrian crossings, quick bicycle connectors, and a couple not-too-huge bridges shared with cars. One of the most interesting bridges we’ll encounter (near <a href="https://www.openstreetmap.org/#map=19/40.07189/-75.22563">40.07189°N, 75.22563°W</a>) is the historic <a href="https://en.wikipedia.org/wiki/Thomas_Mill_Covered_Bridge">Thomas Mill Covered Bridge</a>. Built in 1855 and fixed up by the <a href="https://en.wikipedia.org/wiki/Works_Progress_Administration">Works Progress Administration</a> in 1939, it’s the oldest covered bridge in any major US City.</p>
<p><img src="images/philly-thomas-mill-bridge.jpg" alt="historic black and white photograph of a covered bridge" /></p>
<p>Just like the Thomas Mill bridge probably felt in 1938, our code could benefit from a good <a href="https://en.wikipedia.org/wiki/New_Deal">deal</a> of tender loving care. One thing you may have noticed is the repetitive nature of <code>get</code>ting numbered fields from the CSV and then <code>expect</code>ing no errors:</p>
<header class="codeblock-header">Unfortunate Boilerplate</header>
<pre><code class="language-rust ignore">let creek_name = creek_segment.get(0).expect(&quot;'creek_name' field must be present&quot;);
let infrastructure_label = creek_segment.get(1).expect(&quot;'inf1' field must be present&quot;);
let geometry_str = creek_segment.get(2).expect(&quot;`geometry` field must be present&quot;);
</code></pre>
<p>For each row in the CSV, getting fields by number in an ad-hoc fashion like this is simple, but it’s a little loosey-goosey: We have to remember what order the fields are in and also write some boring error-checking boilerplate.</p>
<h2 id="a-structured-alternative"><a class="header" href="#a-structured-alternative">A <em>Struct</em>ured Alternative</a></h2>
<p>Instead, we can parse each row into a rigidly defined <code>struct</code>. Let’s take another look at our data:</p>
<div class="table-wrapper"><table><thead><tr><th>creek_name</th><th>inf1</th><th>geometry</th></tr></thead><tbody>
<tr><td>Wissahickon Creek</td><td>Bridged</td><td>MULTIPOLYGON(….)</td></tr>
</tbody></table>
</div>
<p>This schema can be converted into a Rust struct like this:</p>
<header class="codeblock-header">A Row in the CSV as a Rust Struct</header>
<pre><code class="language-rust">struct CreekSegment {
  creek_name: String,
  inf1: String,
  geometry: geo::geometry::Geometry
}
</code></pre>
<div class="callout rust-callout">
<h3 id="structs-in-rust"><a class="header" href="#structs-in-rust">Structs in rust</a></h3>
<p>A struct is a type that holds multiple related values. You can read more in <a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html">The Rust Book</a>.</p>
</div>
<p>Notice how each field of the <code>CreekSegment</code> struct corresponds to a column in our CSV input. From here, we could write boilerplate code to populate each of these fields:</p>
<header class="codeblock-header">Revised, but Still Unfortunate, Boilerplate</header>
<pre><code class="language-rust ignore">let creek_name = creek_segment.get(0).expect(&quot;'creek_name' field must be present&quot;);
let infrastructure_label = creek_segment.get(1).expect(&quot;'inf1' field must be present&quot;);
let geometry_str = creek_segment.get(2).expect(&quot;`geometry` field must be present&quot;);

let geometry = Geometry::try_from_wkt_str(geometry_str).expect(&quot;wkt must be valid&quot;);

let creek_segment = CreekSegment {
  creek_name,
  inf1: infrastructure_label,
  geometry
};
</code></pre>
<p>Deserializing information from a CSV file into a more ergonomic form like this isn’t exactly cutting-edge stuff in the world of Computer Science — actually it’s kind of tedious and error prone. Fortunately for us, we can stand on the shoulders of giants and turn to the wisdom of those who’ve deserialized before.</p>
<h2 id="serde-slayer-of-boilerplate"><a class="header" href="#serde-slayer-of-boilerplate">Serde, Slayer of Boilerplate</a></h2>
<p>The excellent <a href="https://serde.rs"><code>serde</code></a> crate is a framework for <strong>ser</strong>ializing and <strong>de</strong>serializing data across a variety of formats. We can use serde to annotate the above struct declaration, then build these structs from a CSV without all the verbose error checking and field assignment code.</p>
<header class="codeblock-header">Declarative Processing with Serde</header>
<pre><code class="language-rust">#[derive(serde::Deserialize)]
struct CreekSegment {
  creek_name: String,

  // serde offers some customizations so that we can use sensible
  // names in our code without having to modify our source data, whose
  // names we might not control.
  #[serde(rename = &quot;inf1&quot; )]
  infrastructure_label: String,

  // serde has built-in support for common data types like numbers and strings,
  // and it also allows other crates (like `wkt`) to build custom deserializers
  // so that we can create complex data types (like this `Geometry`)
  // directly from our input data.
  #[serde(deserialize_with = &quot;wkt::deserialize_wkt&quot;)]
  geometry: geo::geometry::Geometry
}
</code></pre>
<div class="callout rust-callout">
<h2 id="attributes-in-rust"><a class="header" href="#attributes-in-rust">Attributes in Rust</a></h2>
<p>In the above Rust code, the <code>#[...]</code> bits are called <em>attributes</em>. The <a href="https://doc.rust-lang.org/reference/attributes.html">official Rust documentation on attributes</a> is a little long in the tooth, but that’s because attributes are really powerful and can be used for a lot of different things. At the risk of oversimplifying, attributes are just a way to give pieces of code extra behavior. In this case, by annotating our struct with <code>#[derive(serde::Deserialize)]</code>, we give our struct the ability to be built from a .csv file or other serde data sources. We then tweak the way that serde will build our struct with the serde-specific <code>#[serde(...)]</code> attributes.</p>
</div>
<h2 id="keeping-it-tidy"><a class="header" href="#keeping-it-tidy">Keeping It Tidy</a></h2>
<p>Finally, before we return to our example, a struct like this is also the perfect place to hang some little helper methods:</p>
<header class="codeblock-header">Organizing Our Code with Struct Helper Methods</header>
<pre><code class="language-rust"><span class="boring">#[derive(serde::Deserialize)]
</span><span class="boring">struct CreekSegment {
</span><span class="boring">  creek_name: String,
</span><span class="boring">
</span><span class="boring">  #[serde(rename = &quot;inf1&quot; )]
</span><span class="boring">  infrastructure_label: String,
</span><span class="boring">
</span><span class="boring">  #[serde(deserialize_with = &quot;wkt::deserialize_wkt&quot;)]
</span><span class="boring">  geometry: geo::geometry::Geometry
</span><span class="boring">}
</span><span class="boring">
</span>impl CreekSegment {
  fn is_bridge(&amp;self) -&gt; bool {
    self.infrastructure_label == &quot;Bridged&quot;
  }

  fn centroid(&amp;self) -&gt; geo::Point {
    use geo::algorithm::Centroid;
    self.geometry.centroid().expect(&quot;a centroid exists for any non-empty geometry&quot;)
  }

  fn is_acceptable_size(&amp;self) -&gt; bool {
     // We're not intested in walking across large automobile bridges.
     self.square_meters() &lt; 250.0
  }

  fn square_meters(&amp;self) -&gt; f64 {
    use geo::algorithm::Area;
    use proj::Transform;

    // In the previous article about projections, we learned how to transform lat/lon to a local
    // projection to get useful area calculations.
    //
    // WGS84 - World Geodetic System, aka lat/lon
    // EPSG:3364 - NAD83(HARN) / Pennsylvania South (meters)
    let geometry_in_meters = self.geometry.transformed_crs_to_crs(&quot;WGS84&quot;, &quot;EPSG:3364&quot;).expect(&quot;valid transformation&quot;);
    geometry_in_meters.unsigned_area()
  }
}
</code></pre>
<p>Let’s see how we can use the above code to clean up our earlier implementation:</p>
<header class="codeblock-header">Processing a CSV with Serde</header>
<pre><code class="language-rust"><span class="boring">use csv;
</span><span class="boring">use geo::algorithm::Area;
</span><span class="boring">use geo::geometry::{Point, Geometry};
</span><span class="boring">use wkt;
</span><span class="boring">
</span><span class="boring">#[derive(serde::Deserialize)]
</span><span class="boring">struct CreekSegment {
</span><span class="boring">  creek_name: String,
</span><span class="boring">
</span><span class="boring">  #[serde(rename = &quot;inf1&quot; )]
</span><span class="boring">  infrastructure_label: String,
</span><span class="boring">
</span><span class="boring">  #[serde(deserialize_with = &quot;wkt::deserialize_wkt&quot;)]
</span><span class="boring">  geometry: geo::geometry::Geometry
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl CreekSegment {
</span><span class="boring">  fn is_bridge(&amp;self) -&gt; bool {
</span><span class="boring">    self.infrastructure_label == &quot;Bridged&quot;
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn centroid(&amp;self) -&gt; geo::Point {
</span><span class="boring">    use geo::algorithm::Centroid;
</span><span class="boring">    self.geometry.centroid().expect(&quot;a centroid exists for any non-empty geometry&quot;)
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn is_acceptable_size(&amp;self) -&gt; bool {
</span><span class="boring">     // We're not intested in walking across large automobile bridges.
</span><span class="boring">     self.square_meters() &lt; 250.0
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn square_meters(&amp;self) -&gt; f64 {
</span><span class="boring">    use geo::algorithm::Area;
</span><span class="boring">    use proj::Transform;
</span><span class="boring">
</span><span class="boring">    // In the previous article about projections, we learned how to transform lat/lon to a local
</span><span class="boring">    // projection to get useful area calculations.
</span><span class="boring">    //
</span><span class="boring">    // WGS84 - World Geodetic System, aka lat/lon
</span><span class="boring">    // EPSG:3364 - NAD83(HARN) / Pennsylvania South (meters)
</span><span class="boring">    let geometry_in_meters = self.geometry.transformed_crs_to_crs(&quot;WGS84&quot;, &quot;EPSG:3364&quot;).expect(&quot;valid transformation&quot;);
</span><span class="boring">    geometry_in_meters.unsigned_area()
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">let mut feature_reader = {
</span><span class="boring">  use std::fs::File;
</span><span class="boring">  let file = File::open(&quot;src/data/philly_waterways/philly_waterways.csv&quot;).expect(&quot;file path must be valid&quot;);
</span><span class="boring">  csv::Reader::from_reader(file)
</span><span class="boring">};
</span><span class="boring">
</span>let mut acceptable_walkabout_bridges: Vec&lt;CreekSegment&gt; = vec![];

for record in feature_reader.deserialize() {

  // All of our error checking and field parsing can be replaced by
  // a single line. The rest is automatically inferred from our
  // serde-annotated struct declaration.
  let creek_segment: CreekSegment = record.expect(&quot;creek segment must be valid&quot;);

  // At this point we know all the fields of creek_segment
  // have been populated.

  // We're only interested in Bridged segments.
  if !creek_segment.is_bridge() {
    continue;
  }

  // We're only interested in bridges that cross Wissahickon Creek.
  if creek_segment.creek_name != &quot;Wissahickon Creek&quot; {
    continue;
  }

  // Ok, we've utilized some attributes to narrow our search,
  // now let's dig deeper with some geometric analysis.

  let bridge_centroid = creek_segment.centroid();

  // We're only interested in the part of the Wissahickon Creek that's within
  // the Wissahickon Valley Park.
  let SOUTHERN_PARK_BORDER = 40.013214;
  let NORTHERN_PARK_BORDER = 40.084306;
  if bridge_centroid.y() &lt; SOUTHERN_PARK_BORDER || bridge_centroid.y() &gt; NORTHERN_PARK_BORDER {
    continue;
  }

  // We're not intested in walking across large automobile bridges.
  if !creek_segment.is_acceptable_size() {
    continue;
  }

  // Using attribute data and geometric processing, we've identified a good walking bridge!
  acceptable_walkabout_bridges.push(creek_segment);
}

<span class="boring">assert_eq!(acceptable_walkabout_bridges.len(), 8);
</span><span class="boring">approx::assert_relative_eq!(acceptable_walkabout_bridges[3].centroid(), Point::new(-75.22563703858332, 40.071892693259315));
</span></code></pre>
<p>Using serde and structs like this is completely optional, but it can help keep your code tidy — especially as programs get more complex. If you prefer the ad-hoc style of the original example (e.g. accessing fields by number) and you don’t care about adding any cute little helper methods, that’s totally fine. Even if you aren’t doing calculations on rivers, just go with the flow.</p>
<h2 id="csv-u-l8r"><a class="header" href="#csv-u-l8r">CSV U L8R</a></h2>
<p>CSV files can feel charmingly anachronistic, like a weird antique tool that sometimes still works surprisingly well. Tons of programs can read and write CSV files, and you can quickly and easily examine their contents in any spreadsheet app. However, this simplicity often comes at a price, and the limitations of the format are not always immediately obvious.</p>
<p>For example, when someone sends you a CSV file that contains geographic data, the layout is always kind of a new mystery to be solved. There is no strong convention for the way its columns will be named, where they will be positioned, or how its geometry will be represented. Although WKT is common, it’s far from universal: A CSV of points, for instance, will sometimes include two <code>latitude</code> and <code>longitude</code> columns instead of a single WKT column.</p>
<p>Another problem with CSV files is that it’s not always clear what type of information is in a column:</p>
<div class="table-wrapper"><table><thead><tr><th>phone</th><th>description</th></tr></thead><tbody>
<tr><td>311</td><td>info</td></tr>
<tr><td>911</td><td>emergency</td></tr>
<tr><td>…</td><td>…</td></tr>
<tr><td>1-818-912-8200 ext. 4</td><td>office</td></tr>
</tbody></table>
</div>
<p>Unless you examine the entire list in advance, you might not realize that <code>phone</code> is a text column, not a numeric one. Some formats are always clear about the distinction between numbers and text, but CSV isn’t one of them.</p>
<p>This lack of standardization means that whenever you encounter geographic data stored in a CSV, first you have to dig around a bit to orient yourself and figure out how to align your program with the CSV author’s conventions.</p>
<h2 id="omgeojson"><a class="header" href="#omgeojson">OMGeoJSON</a></h2>
<p><a href="https://geojson.org/">GeoJSON</a> is another available format for representing geospatial features (geometry + data) with a different set of trade-offs. Seeing is believing, so here’s how some of our previous data could be structured in GeoJSON:</p>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;FeatureCollection&quot;,
  &quot;features&quot;: [
    {
      &quot;type&quot;: &quot;Feature&quot;,
      &quot;properties&quot;: {
        &quot;creek_name&quot;: &quot;Haines-Dittingers Creek&quot;,
        &quot;inf1&quot;: &quot;Impoundment&quot;
      },
      &quot;geometry&quot;: {
        &quot;type&quot;: &quot;Polygon&quot;,
        &quot;coordinates&quot;: [
          [
            [
              -75.2512163863237,
              40.2171158853747
            ],
            [
              -75.2512026232353,
              40.217108225299
            ],
            [
              -75.2511416958994,
              40.2170817213073
            ],
            ...
          ]
        ]
      }
    },
    {
      &quot;type&quot;: &quot;Feature&quot;,
      &quot;properties&quot;: {
        &quot;creek_name&quot;: &quot;Wissahickon Creek&quot;,
        &quot;inf1&quot;: &quot;Bridged&quot;
      },
      &quot;geometry&quot;: {
        &quot;type&quot;: &quot;Polygon&quot;,
        &quot;coordinates&quot;: [
          [
            [
              -75.25461361296729,
              40.1820761530732
            ],
            [
              -75.2545303055114,
              40.1819601471794
            ],
            [
              -75.25446431085831,
              40.1820297432309
            ],
            ...
          ]
        ]
      }
    },
    ...
}
</code></pre>
<p>GeoJSON is pretty popular, especially for mapping and other geospatial applications on the web. This is largely because it’s an extension of <a href="https://en.wikipedia.org/wiki/JSON">JSON</a>, which is a format that web browsers already use extensively for all kinds of information. That makes it easy for web programmers to manipulate GeoJSON using JavaScript in the browser.</p>
<p>However, GeoJSON has long since left the domain of “web-only” formats, and now many other geospatial tools know how to handle it too: <a href="https://qgis.org">QGIS</a>, <a href="https://libgeos.org/">GEOS</a>, <a href="https://locationtech.github.io/jts/">JTS</a>, <a href="https://gdal.org/">GDAL</a>, and <a href="https://github.com/shapely/shapely">Shapely</a> are all fluent in GeoJSON.</p>
<p>Let’s run our Wissahickon calculations again, only this time using information structured in GeoJSON format instead of a CSV. What’s nice about using serde, is just how little of our code actually needs to change to support this completely different encoding:</p>
<header class="codeblock-header">Process GeoJSON with Serde</header>
<pre><code class="language-rust"><span class="boring">use csv;
</span><span class="boring">use geo::algorithm::Area;
</span><span class="boring">use geo::geometry::{Point, Geometry};
</span><span class="boring">use wkt;
</span><span class="boring">
</span>#[derive(serde::Deserialize)]
struct CreekSegment {
   creek_name: String,

   #[serde(rename = &quot;inf1&quot; )]
   infrastructure_label: String,

   // #[serde(deserialize_with = &quot;wkt::deserialize_wkt&quot;)]
   #[serde(deserialize_with = &quot;geojson::deserialize_geometry&quot;)]
   geometry: geo::geometry::Geometry
}

<span class="boring">impl CreekSegment {
</span><span class="boring">  fn is_bridge(&amp;self) -&gt; bool {
</span><span class="boring">    self.infrastructure_label == &quot;Bridged&quot;
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn centroid(&amp;self) -&gt; geo::Point {
</span><span class="boring">    use geo::algorithm::Centroid;
</span><span class="boring">    self.geometry.centroid().expect(&quot;a centroid exists for any non-empty geometry&quot;)
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn is_acceptable_size(&amp;self) -&gt; bool {
</span><span class="boring">     // We're not intested in walking across large automobile bridges.
</span><span class="boring">     self.square_meters() &lt; 250.0
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn square_meters(&amp;self) -&gt; f64 {
</span><span class="boring">    use geo::algorithm::Area;
</span><span class="boring">    use proj::Transform;
</span><span class="boring">
</span><span class="boring">    // In the previous article about projections, we learned how to transform lat/lon to a local
</span><span class="boring">    // projection to get useful area calculations.
</span><span class="boring">    //
</span><span class="boring">    // WGS84 - World Geodetic System, aka lat/lon
</span><span class="boring">    // EPSG:3364 - NAD83(HARN) / Pennsylvania South (meters)
</span><span class="boring">    let geometry_in_meters = self.geometry.transformed_crs_to_crs(&quot;WGS84&quot;, &quot;EPSG:3364&quot;).expect(&quot;valid transformation&quot;);
</span><span class="boring">    geometry_in_meters.unsigned_area()
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span>let mut feature_reader = {
  use std::fs::File;
  let file = File::open(&quot;src/data/philly_waterways/philly_waterways.geojson&quot;).expect(&quot;file path must be valid&quot;);
  // csv::Reader::from_reader(file)
  geojson::FeatureReader::from_reader(file)
};

let mut acceptable_walkabout_bridges: Vec&lt;CreekSegment&gt; = vec![];

for record in feature_reader.deserialize().expect(&quot;valid feature collection&quot;) {

  // Thanks to the magic of serde, the rest of this example is exactly
  // the same as the serde CSV example above!
  //
  // We've hidden it for brevity, but you can see the rest of the code if you click
  // the &quot;eyeball&quot; icon in the top right corner of this code block.

  // ...

<span class="boring">  // All of our error checking and field parsing can be replaced by
</span><span class="boring">  // a single line. The rest is automatically inferred from our
</span><span class="boring">  // serde-annotated struct declaration.
</span><span class="boring">  let creek_segment: CreekSegment = record.expect(&quot;creek segment must be valid&quot;);
</span><span class="boring">
</span><span class="boring">  // At this point we know all the fields of creek_segment
</span><span class="boring">  // have been populated.
</span><span class="boring">
</span><span class="boring">  // We're only interested in Bridged segments.
</span><span class="boring">  if !creek_segment.is_bridge() {
</span><span class="boring">    continue;
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  // We're only interested in bridges that cross Wissahickon Creek.
</span><span class="boring">  if creek_segment.creek_name != &quot;Wissahickon Creek&quot; {
</span><span class="boring">    continue;
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  // Ok, we've utilized some attributes to narrow our search,
</span><span class="boring">  // now let's dig deeper with some geometric analysis.
</span><span class="boring">
</span><span class="boring">  let bridge_centroid = creek_segment.centroid();
</span><span class="boring">
</span><span class="boring">  // We're only interested in the part of the Wissahickon Creek that's within
</span><span class="boring">  // the Wissahickon Valley Park.
</span><span class="boring">  let SOUTHERN_PARK_BORDER = 40.013214;
</span><span class="boring">  let NORTHERN_PARK_BORDER = 40.084306;
</span><span class="boring">  if bridge_centroid.y() &lt; SOUTHERN_PARK_BORDER || bridge_centroid.y() &gt; NORTHERN_PARK_BORDER {
</span><span class="boring">    continue;
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  // We're not intested in walking across large automobile bridges.
</span><span class="boring">  if !creek_segment.is_acceptable_size() {
</span><span class="boring">    continue;
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  // Using attribute data and geometric processing, we've identified a good walking bridge!
</span>  acceptable_walkabout_bridges.push(creek_segment);
}

assert_eq!(acceptable_walkabout_bridges.len(), 8);
approx::assert_relative_eq!(acceptable_walkabout_bridges[3].centroid(), Point::new(-75.22563703858332, 40.071892693259315));
</code></pre>
<h2 id="straying-from-the-format"><a class="header" href="#straying-from-the-format">Straying from the Format</a></h2>
<p>Ubiquity is arguably GeoJSON’s biggest upside, but it’s not the perfect format for everything. </p>
<p><img src="images/philly-sinkhole-dump-truck.jpg" alt="Dump truck on the street, whose read wheel has fallen into a sinkhole" />
<span class="photo-credit">Photo via <a href="https://twitter.com/orentalks/status/1070372166867320832">@orentalks</a></span></p>
<p>Like a truck on its way to fix a sinkhole (but then falling into another sinkhole before it can get there), it’s good to be aware of a few potential pitfalls in advance.</p>
<p>If you scroll up to the GeoJSON sample above, you may notice that the way it represents geometry is quite verbose. Unlike WKT, it’s not as easy for humans to read at a glance, and compared to some other formats, it’s not very efficient for computers to store or transmit. JSON editors exist, but they aren’t nearly as powerful or widespread as spreadsheet programs that can easily read CSVs. GeoJSON also lacks a <em>spatial index</em> (future topic!) so certain operations on complex geometries are slow.</p>
<p>There’s an entire world of alternative formats available — each with their own set of trade-offs. Luckily, Rust has support for pretty much all of them at this point. Aside from <a href="https://docs.rs/wkt">WKT</a> and <a href="https://docs.rs/geojson">GeoJSON</a>, other popular choices include:</p>
<ul>
<li><a href="https://docs.rs/shapefile">Shapefiles (.shp)</a> - A venerable (and often maligned) all-purpose format.</li>
<li><a href="https://docs.rs/geozero">Geopackage (.gpx)</a> - The “preferred” format for lots of desktop GIS applications these days, built on top of <a href="https://www.sqlite.org">SQLite</a>.</li>
<li><a href="https://docs.rs/flatgeobuf">Flatgeobuf (.fgb)</a> - A newer format that is well-suited for efficient and random read-only access.</li>
</ul>
<h2 id="give-yourself-some-space"><a class="header" href="#give-yourself-some-space">Give Yourself Some Space</a></h2>
<p>Up next, we’ll learn how to combine attributes across multiple data sources using <em>spatial joins</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="join-the-party"><a class="header" href="#join-the-party">Join the Party</a></h1>
<p>Imagine living in New York City. Good pizza, Broadway, and one of the US’s best collections of <a href="https://data.ny.gov/">open data</a> have never felt closer to home. Other than pizza, what really makes a city great though, are the people who live there. Think about the people who help fill the blank spaces in your life. The shape of each relationship is usually a little different, but it’s almost always possible to find some common ground. In this New York City life of our imagination, let’s imagine some of the <a href="https://en.wikipedia.org/wiki/Friends">Friends</a> we’d like to spend time with, and start to think about where we could all hang out.</p>
<p><img src="images/nyc-friends.jpg" alt="A scene from the Friends television show, with everyone inside the crowded Central Perk cafe" />
<span class="photo-credit">Courtesy NBC</span></p>
<h2 id="drink-from-the-firehose"><a class="header" href="#drink-from-the-firehose">Drink from the Firehose</a></h2>
<p>That cafe looks a bit stuffy and a bit dated. Let’s embrace the timeless joy of the great outdoors and look at a list of parks in the city — because even if the weather is bad, your friends will still be there for you (when the rain starts to pour). Somewhere in these shaded shapes, we can see the faint outline of a party beginning to form:</p>
<p><img src="images/nyc-parks.png" alt="The 2029 parks of New York City" /></p>
<p>Fortunately for us, we also have a list of every public drinking fountain that will let us sip some of NYC’s <a href="https://www1.nyc.gov/site/greenyc/take-action/drink-tap-water.page">“world-renowned”</a> tap water whenever the conversation starts to feel a little dry:</p>
<p><img src="images/nyc-water-fountains.png" alt="The 3120 drinking fountains of New York City" /></p>
<h2 id="filtered-water"><a class="header" href="#filtered-water">Filtered Water</a></h2>
<p>Solving spatial problems often involves setting up a sort of <a href="https://en.wikipedia.org/wiki/Meet_cute">meet cute</a> scenario between different data sources. Similar to the will-they-or-won’t-they dynamic between Rachel and Ross, we have our own relationship (between drinking fountains and parks) that we need to explore. Let’s see how many of these parks contain at least one of these drinking fountains.</p>
<header class="codeblock-header">Count MultiPolygons That Contain at Least One Point</header>
<pre><code class="language-rust">use geojson::de::deserialize_features_from_feature_collection;
use geo::algorithm::Contains;

// a simple helper to open a file reader
fn reader(filename: &amp;str) -&gt; std::io::BufReader&lt;std::fs::File&gt; {
  let path = format!(&quot;src/data/nyc/{filename}&quot;);
  std::io::BufReader::new(std::fs::File::open(path).expect(&quot;file path must be valid&quot;))
}

let parks: Vec&lt;geo::MultiPolygon&gt; = deserialize_features_from_feature_collection(reader(&quot;parks.geojson&quot;))
    .map(|park_result: geojson::Result&lt;geojson::Feature&gt;| {
      let park_feature = park_result.expect(&quot;valid feature&quot;);
      geo::MultiPolygon::try_from(park_feature).expect(&quot;valid conversion&quot;)
    })
    .collect();

let fountains: Vec&lt;geo::Point&gt; = deserialize_features_from_feature_collection(reader(&quot;drinking_fountains.geojson&quot;))
    .map(|feature_result: geojson::Result&lt;geojson::Feature&gt;| {
      let feature = feature_result.expect(&quot;valid Feature&quot;);
      geo::Point::try_from(feature).expect(&quot;valid conversion&quot;)
    }).collect();

let mut parks_with_fountains = 0;
for park in &amp;parks {
  for fountain in &amp;fountains {
    if park.contains(fountain) {
      parks_with_fountains += 1;
      break;
    }
  }
}

assert_eq!(parks_with_fountains, 902);

let parks_without_fountains = parks.len() - parks_with_fountains;
assert_eq!(parks_without_fountains, 1127);
</code></pre>
<p>A little less than half of NYC’s parks have drinking fountains. Good to know!</p>
<h2 id="thirst-for-knowledge"><a class="header" href="#thirst-for-knowledge">Thirst for Knowledge</a></h2>
<p>Counting is simple, but oftentimes we will need to do something more complex like taking certain attributes from one data source and combining those attributes with another data source based on their spatial relationship.</p>
<p>Let’s look at some selected data from two data sources:</p>
<p><strong>List of Parks (Same As Above)</strong></p>
<div class="table-wrapper"><table><thead><tr><th>park_name</th><th>park_shape</th></tr></thead><tbody>
<tr><td>Gilbert Ramirez Park</td><td><code>MULTIPOLYGON(((-73.93418260...</code></td></tr>
<tr><td>Spargo Park</td><td><code>MULTIPOLYGON(((-73.89721950...</code></td></tr>
<tr><td>Turtle Playground</td><td><code>MULTIPOLYGON(((-73.82693385...</code></td></tr>
<tr><td>…</td><td>…</td></tr>
</tbody></table>
</div>
<p><strong>The Five Boroughs</strong></p>
<p><img src="images/nyc-boroughs.png" alt="The five boroughs of New York City" /></p>
<div class="table-wrapper"><table><thead><tr><th>borough_name</th><th>borough_shape</th></tr></thead><tbody>
<tr><td>Brooklyn</td><td><code>MULTIPOLYGON(((-73.86327...)</code></td></tr>
<tr><td>Queens</td><td><code>MULTIPOLYGON(((-73.82644...)</code></td></tr>
<tr><td>…</td><td>…</td></tr>
</tbody></table>
</div>
<p>It’s truncated in the tables above, but the park and borough data sources include detailed shape information. The smaller shapes of each <em>park</em> can be positioned within the larger shapes that comprise each <em>borough</em>. Because our friends live in different areas, a list like this could really help us narrow down where we want to get together:</p>
<blockquote>
<ul>
<li>Option 1: Gilbert Ramirez Park in Brooklyn</li>
<li>Option 2: Spargo Park in Queens</li>
<li>Option 3: Turtle Playground in Queens</li>
<li>…</li>
</ul>
</blockquote>
<p>In order to produce a list like this, we need to combine the park name from the first data source with the borough that contains it from the second data source.</p>
<p>If you’ve worked with SQL before, you might be thinking that this sounds a bit like a <a href="https://en.wikipedia.org/wiki/Join_(SQL)">JOIN clause</a>, and you’ll no doubt be delighted to know that this kind of operation is indeed referred to as a <em>spatial join</em>. If you’ve never worked with SQL before, don’t worry, you have an even bigger reason to be delighted.</p>
<p>Let’s start building a list of venues by combining each park with the name of the borough that the park is in.</p>
<header class="codeblock-header">Combining Attributes From Multiple Features</header>
<pre><code class="language-rust"><span class="boring">use geo::geometry::{MultiPolygon, Point};
</span><span class="boring">use geo::algorithm::Intersects;
</span><span class="boring">
</span><span class="boring">use geojson::de::{deserialize_feature_collection_to_vec, deserialize_geometry};
</span><span class="boring">
</span><span class="boring">fn reader(filename: &amp;str) -&gt; std::io::BufReader&lt;std::fs::File&gt; {
</span><span class="boring">  let path = format!(&quot;src/data/nyc/{filename}&quot;);
</span><span class="boring">  std::io::BufReader::new(std::fs::File::open(path).expect(&quot;file path must be valid&quot;))
</span><span class="boring">}
</span>
// Using what we learned in the previous section on Features, we'll
// deserialize the input GeoJSON into structs using serde.

// First Input
#[derive(serde::Deserialize)]
struct Park {
  #[serde(deserialize_with=&quot;deserialize_geometry&quot;)]
  geometry: geo::MultiPolygon,

  #[serde(rename=&quot;signname&quot;)]
  name: String
}

let parks = deserialize_feature_collection_to_vec::&lt;Park&gt;(reader(&quot;parks.geojson&quot;)).expect(&quot;valid geojson&quot;);

// Second Input
#[derive(serde::Deserialize)]
struct Borough {
  #[serde(deserialize_with=&quot;deserialize_geometry&quot;)]
  geometry: geo::MultiPolygon,

  #[serde(rename=&quot;boro_name&quot;)]
  name: String
}

let boroughs = deserialize_feature_collection_to_vec::&lt;Borough&gt;(reader(&quot;boroughs.geojson&quot;)).expect(&quot;valid geojson&quot;);

// Output
struct PartyVenue {
  park_geometry: MultiPolygon,
  park_name: String,
  borough_name: String,
}

let mut venues: Vec&lt;PartyVenue&gt; = Vec::new();

for park in &amp;parks {
  for borough in &amp;boroughs {
    if borough.geometry.intersects(&amp;park.geometry) {
      let venue = PartyVenue {
        park_name: park.name.clone(),
        park_geometry: park.geometry.clone(),
        borough_name: borough.name.clone(),
      };
      venues.push(venue);
      break;
    }
  }
}

let first_venue = &amp;venues[0];
assert_eq!(first_venue.park_name, &quot;Devoe Park&quot;);
assert_eq!(first_venue.borough_name, &quot;Bronx&quot;);

<span class="boring">// There's one phantom park in the data set that's outside of any borough boundaries — Wild!
</span><span class="boring">assert_eq!(venues.len(), parks.len() - 1);
</span></code></pre>
<p>We’ve produced a list of parks spatially joined to their borough name, but it’s a huge list of options. How can we refine this list to surface only the best places?</p>
<h2 id="water-cooler"><a class="header" href="#water-cooler">Water, Cooler</a></h2>
<p>If <a href="https://www.nycgovparks.org/parks/central-park">Central Park</a> is as mainstream as it gets, which open spaces are more like the avant-garde Vapor Wave Jazz that your hipster friends just can’t get enough of these days? Let’s augment our earlier code to filter out the mainstream (largest) parks, while still ensuring we’ll be able to get a drink of New York’s finest (water).</p>
<p>We want to produce something like this:</p>
<div class="table-wrapper"><table><thead><tr><th>park</th><th>borough</th><th>fountains</th><th>square_meters</th></tr></thead><tbody>
<tr><td>Tiny Town</td><td>Queens</td><td>2</td><td>100</td></tr>
<tr><td>Polly Pocket Park</td><td>Brooklyn</td><td>3</td><td>200</td></tr>
<tr><td>Honey I Shrunk the Esplanade</td><td>Bronx</td><td>1</td><td>300</td></tr>
<tr><td>…</td><td>…</td><td>…</td><td>…</td></tr>
</tbody></table>
</div><header class="codeblock-header">Combining Attributes From Multiple Features and Filtering the Result</header>
<pre><code class="language-rust"><span class="boring">use geo::geometry::{MultiPolygon, MultiPoint, Point};
</span><span class="boring">use geo::algorithm::{Area, Contains, Intersects};
</span><span class="boring">
</span><span class="boring">use geojson::de::{deserialize_feature_collection_to_vec, deserialize_feature_collection, deserialize_features_from_feature_collection, deserialize_geometry};
</span><span class="boring">
</span><span class="boring">fn reader(filename: &amp;str) -&gt; std::io::BufReader&lt;std::fs::File&gt; {
</span><span class="boring">  let path = format!(&quot;src/data/nyc/{filename}&quot;);
</span><span class="boring">  std::io::BufReader::new(std::fs::File::open(path).expect(&quot;file path must be valid&quot;))
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// First Input
</span><span class="boring">#[derive(serde::Deserialize, Debug)]
</span><span class="boring">struct Park {
</span><span class="boring">  #[serde(deserialize_with=&quot;deserialize_geometry&quot;)]
</span><span class="boring">  geometry: geo::MultiPolygon,
</span><span class="boring">
</span><span class="boring">  #[serde(rename=&quot;signname&quot;)]
</span><span class="boring">  name: String
</span><span class="boring">}
</span><span class="boring">let parks = deserialize_feature_collection_to_vec::&lt;Park&gt;(reader(&quot;parks.geojson&quot;)).expect(&quot;valid geojson&quot;);
</span><span class="boring">
</span><span class="boring">// Second Input
</span><span class="boring">#[derive(serde::Deserialize)]
</span><span class="boring">struct Borough {
</span><span class="boring">  #[serde(deserialize_with=&quot;deserialize_geometry&quot;)]
</span><span class="boring">  geometry: geo::MultiPolygon,
</span><span class="boring">
</span><span class="boring">  #[serde(rename=&quot;boro_name&quot;)]
</span><span class="boring">  name: String
</span><span class="boring">}
</span><span class="boring">let boroughs = deserialize_feature_collection_to_vec::&lt;Borough&gt;(reader(&quot;boroughs.geojson&quot;)).expect(&quot;valid geojson&quot;);
</span><span class="boring">
</span>// Output
struct PartyVenue {
  park: String,
  borough: String,
  geometry: MultiPolygon,
  square_meters: f64,
  fountains: usize,
}

let mut venues: Vec&lt;PartyVenue&gt; = Vec::new();
for park in &amp;parks {
  for borough in &amp;boroughs {
    if borough.geometry.intersects(&amp;park.geometry) {
      use proj::Transform;
      // Project the geometry in order to calculate a useful area.
      // See our first section for more on projections.
      //
      // EPSG:32115 - New York Eastern (meters)
      let square_meters = park.geometry
        .transformed_crs_to_crs(&quot;WGS84&quot;, &quot;EPSG:32115&quot;)
        .expect(&quot;valid projection&quot;)
        .unsigned_area();

      let venue = PartyVenue {
        park: park.name.clone(),
        borough: borough.name.clone(),
        geometry: park.geometry.clone(),
        square_meters,
        fountains: 0, // we'll populate this field later
      };
      venues.push(venue);
      break;
    }
  }
}

let fountains: Vec&lt;geo::Point&gt; = deserialize_features_from_feature_collection(reader(&quot;drinking_fountains.geojson&quot;))
    .map(|feature_result: geojson::Result&lt;geojson::Feature&gt;| {
      let feature = feature_result.expect(&quot;valid Feature&quot;);
      geo::Point::try_from(feature).expect(&quot;valid conversion&quot;)
    }).collect();

for fountain in &amp;fountains {
  for venue in &amp;mut venues {
    if venue.geometry.contains(fountain) {
      venue.fountains += 1;
      break;
    }
  }
}

// We're only interested in parks that have at least one water fountain
venues = venues.into_iter().filter(|venue| venue.fountains &gt; 0).collect();

// Sort by the size of the park
venues.sort_by(|venue_1, venue_2| venue_1.square_meters.partial_cmp(&amp;venue_2.square_meters).expect(&quot;valid floating point comparison&quot;));

let tiniest_venue = venues.first().unwrap();
assert_eq!(tiniest_venue.park, &quot;Glendale Veterans Triangle&quot;);
assert_eq!(tiniest_venue.borough, &quot;Queens&quot;);
approx::assert_relative_eq!(tiniest_venue.square_meters, 26.263444242984757, max_relative = 1e-5);
assert_eq!(tiniest_venue.fountains, 1);

<span class="boring">let largest_venue = venues.last().unwrap();
</span><span class="boring">assert_eq!(largest_venue.park, &quot;Pelham Bay Park&quot;);
</span><span class="boring">assert_eq!(largest_venue.borough, &quot;Bronx&quot;);
</span><span class="boring">approx::assert_relative_eq!(largest_venue.square_meters, 10835186.669072341, max_relative = 1e-5);
</span><span class="boring">assert_eq!(largest_venue.fountains, 43);
</span></code></pre>
<p>We have found some excellent candidates for a tiny party venue, the tiniest of all being the pint-sized <a href="https://www.nycgovparks.org/parks/glendale-veterans-triangle/monuments/589">Glendale Veterans Triangle</a> in Queens.</p>
<div class="side-by-side">
  <img src="images/nyc-glendale-veterans-triangle-park.jpg" />
  <img src="images/nyc-glendale-veterans-triangle-drinking-fountain.jpg" />
</div>
<p>These off the beaten path parks will let us spend hours of quality time with our friends, all while staying hydrated. What more could you possibly ask for on a lazy day in New York City?</p>
<h2 id="drowning-in-data"><a class="header" href="#drowning-in-data">Drowning in Data</a></h2>
<p>One thing you could definitely ask for are quicker results. The code above works, but it’s really quite slow! Until now we’ve basically brute forced our solutions without much consideration for speed. We can sort of justify our laissez-faire approach to CPU usage for one-off calculations like this, but speed will become increasingly important as our data sets grow larger and processing gets more complicated, or if results need to be recomputed more frequently.</p>
<p>Generally speaking, Rust is “real fast”, but that’s not the whole story. Let’s say you’re trying to get to <a href="https://en.wikipedia.org/wiki/Sugar_Hill,_Manhattan">Harlem</a> in a hurry. If you happen to be <a href="https://en.wikipedia.org/wiki/Tatyana_McFadden">Tatyana McFadden</a>, five-time winner and course record holder for the New York City Marathon women’s weelchair division, you’d do all right. Alternatively, you could just recall that Duke Ellington tune and <a href="https://www.youtube.com/watch?v=1ggcQk67Mco&amp;t=86s">take the A train</a>. With Rust’s natural affinity for speed as a baseline, applying some problem-specific know-how can get us where we’re going without breaking a sweat.</p>
<p>In an upcoming lesson, we’ll explore some of these tricks of the trade to speed up common geospatial operations. Quickly moving through the real world may require a jet engine, but that doesn’t mean that your laptop needs to sound like one. If you’d like to be notified when it’s up, <a href="./contact.html">send us a note</a>, or subscribe to our <a href="rss.xml">rss feed</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contact-the-authors"><a class="header" href="#contact-the-authors">Contact the Authors</a></h1>
<p>We’d love to hear your feedback, corrections, and suggestions for future topics. Contact us at <a href="mailto:book@georust.org">book@georust.org</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="license"><a class="header" href="#license">License</a></h1>
<p>This book is available for you to freely use, duplicate, or modify under the terms of the <a href="https://creativecommons.org/licenses/by/4.0/">CC-BY</a> license.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
